<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>org.elasticsearch.indices.recovery (server 7.11.1 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF8">
<meta name="description" content="declaration: package: org.elasticsearch.indices.recovery">
<meta name="generator" content="javadoc/PackageWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.js"></script>
</head>
<body class="package-declaration">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flexBox">
<header role="banner" class="flexHeader">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="skipNav"><a id="skip.navbar.top">
<!--   -->
</a></div>
</nav>
</header>
<div class="flexContent">
<main role="main">
<div class="header">
<h1 title="Package" class="title">Package&nbsp;org.elasticsearch.indices.recovery</h1>
</div>
<div class="contentContainer">
<section class="packageDescription"><a id="package.description">
<!--   -->
</a>
<div class="block"><p>This package contains the logic for the recovery functionality.</p>

 <h2>Preliminaries</h2>

 Recoveries are started on data nodes as a result of data node discovering shard assignments to themselves in the cluster state. The
 master node sets up these shard allocations in the cluster state (see <a href="../../cluster/routing/ShardRouting.html" title="class in org.elasticsearch.cluster.routing"><code>ShardRouting</code></a>).
 If a data node finds shard allocations that require recovery on itself, it will execute the required recoveries by executing the
 logic starting at <code>IndicesClusterStateService.createOrUpdateShards(org.elasticsearch.cluster.ClusterState)</code>. As the data nodes execute
 the steps of the recovery state machine they report back success or failure to do so to the master node via the transport actions in
 <a href="../../cluster/action/shard/ShardStateAction.html" title="class in org.elasticsearch.cluster.action.shard"><code>ShardStateAction</code></a>, which will then update the shard routing in the cluster state
 accordingly to reflect the status of the recovered shards or to handle failures in the recovery process. Recoveries can have various
 kinds of sources that are modeled via the <a href="../../cluster/routing/RecoverySource.html" title="class in org.elasticsearch.cluster.routing"><code>RecoverySource</code></a> that is communicated to the recovery
 target by <a href="../../cluster/routing/ShardRouting.html#recoverySource()"><code>ShardRouting.recoverySource()</code></a> for each shard routing. These sources and their state
 machines will be described below. The actual recovery process for all of them is started by invoking
 <a href="../../index/shard/IndexShard.html#startRecovery(org.elasticsearch.indices.recovery.RecoveryState,org.elasticsearch.indices.recovery.PeerRecoveryTargetService,org.elasticsearch.indices.recovery.PeerRecoveryTargetService.RecoveryListener,org.elasticsearch.repositories.RepositoriesService,java.util.function.BiConsumer,org.elasticsearch.indices.IndicesService)"><code>IndexShard.startRecovery(org.elasticsearch.indices.recovery.RecoveryState, org.elasticsearch.indices.recovery.PeerRecoveryTargetService, org.elasticsearch.indices.recovery.PeerRecoveryTargetService.RecoveryListener, org.elasticsearch.repositories.RepositoriesService, java.util.function.BiConsumer&lt;java.lang.String, org.elasticsearch.cluster.metadata.MappingMetadata&gt;, org.elasticsearch.indices.IndicesService)</code></a>.

 <h3>Checkpoints</h3>

 Aspects of the recovery logic are based on the concepts of local and global checkpoints. Each operation on a shard is tracked by a
 sequence number as well as the primary term during which it was applied to the index. The sequence number up to which operations have
 been fully processed on a shard is that shard's local checkpoint. The sequence number up to which operations on all replicas for a shard
 have been fully processed is referred to as the global checkpoint. Comparing the local checkpoints of shard copies enables determining
 which operations would have to be replayed to a shard copy to bring it in-sync with the primary shard. By retaining operations in the
 <a href="RecoveryState.Translog.html" title="class in org.elasticsearch.indices.recovery"><code>RecoveryState.Translog</code></a> or in soft deletes, they are available for this kind of replay that
 moves a shard lower local checkpoint up to a higher local checkpoint. The global checkpoint allows for determining which operations have
 been safely processed on all shards and thus don't have to be retained on the primary node for replay to replicas.

 The primary node tracks the global checkpoint for a shard via the <a href="../../index/seqno/ReplicationTracker.html" title="class in org.elasticsearch.index.seqno"><code>ReplicationTracker</code></a>. The primary
 term is tracked by the master node and stored in the cluster state and incremented each time the primary node for a shard changes.

 <h3>Retention Leases</h3>

 The duration for which a shard retains individual operations for replay during recovery is governed by the
 <a href="../../index/seqno/RetentionLease.html" title="class in org.elasticsearch.index.seqno"><code>RetentionLease</code></a> functionality. More information about this functionality can be found in the
 <a href="../../index/seqno/package-summary.html"><code>org.elasticsearch.index.seqno</code></a> package and the "History retention" section in the docs.

 <h2>Recovery Types</h2>

 <h3>1. Peer Recovery</h3>

 Peer recovery is the process of bringing a shard copy on one node, referred to as the target node below, in-sync with the shard copy on
 another node, referred to as the source node below. It is always the primary node of a shard that serves as the source of the recovery.
 On a high level, recovery happens by a combination of comparing and subsequently synchronizing files and operations from the source to
 the target.
 Synchronizing the on-disk file structure on the target with those on the source node is referred to as file-based recovery.
 Synchronizing operations based on comparing checkpoints is commonly referred to as ops-based recovery. As primaries and replicas are
 independent Lucene indices that will execute their Lucene level merges independently the concrete on-disk file structure on a pair of
 primary and replica nodes for a given shard will diverge over time even if both copies of the shard hold the exact same set of documents
 and operations. Peer recovery will therefore try to avoid file-based recovery where possible to reduce the amount of data that has to be
 transferred. It will prefer replaying just those operations missing on the target relative to the source instead as this
 avoids copying files from source to target that could contain data that is for the most part already present on the target.
 Replaying operations is possible as long as the primary node retains the missing operations as soft-deletes in its Lucene index.

 <h4>State Machine</h4>

 Peer recoveries are modeled via a <a href="../../cluster/routing/RecoverySource.PeerRecoverySource.html" title="class in org.elasticsearch.cluster.routing"><code>RecoverySource.PeerRecoverySource</code></a>. They start by moving the
 shard's state to <a href="../../index/shard/IndexShardState.html#RECOVERING"><code>IndexShardState.RECOVERING</code></a> and then triggering the peer recovery through a call
 to <a href="PeerRecoveryTargetService.html#startRecovery(org.elasticsearch.index.shard.IndexShard,org.elasticsearch.cluster.node.DiscoveryNode,org.elasticsearch.indices.recovery.PeerRecoveryTargetService.RecoveryListener)"><code>PeerRecoveryTargetService.startRecovery(org.elasticsearch.index.shard.IndexShard, org.elasticsearch.cluster.node.DiscoveryNode, org.elasticsearch.indices.recovery.PeerRecoveryTargetService.RecoveryListener)</code></a> which results in the following steps being
 executed.

 <ol>
     <li>
         The target shard starts out with a <a href="RecoveryState.html" title="class in org.elasticsearch.indices.recovery"><code>RecoveryState</code></a> at stage
         <a href="RecoveryState.Stage.html#INIT"><code>RecoveryState.Stage.INIT</code></a>. At the start of the peer recovery process, the target node
         will try to recover from its local translog as far as if there are any operations to recover from it. It will first move to
         stage <a href="RecoveryState.Stage.html#INDEX"><code>RecoveryState.Stage.INDEX</code></a> and then try to recover as far as possible from
         existing files and the existing translog. During this process, it will move to
         <a href="RecoveryState.Stage.html#VERIFY_INDEX"><code>RecoveryState.Stage.VERIFY_INDEX</code></a>, verifying that the files on disk are not corrupted,
         then to <a href="RecoveryState.Stage.html#TRANSLOG"><code>RecoveryState.Stage.TRANSLOG</code></a> during recovery from translog.
         A <a href="StartRecoveryRequest.html" title="class in org.elasticsearch.indices.recovery"><code>StartRecoveryRequest</code></a> is then sent to the primary node of the shard to recover by
         the target node for the recovery. This triggers
         <code>PeerRecoverySourceService.recover(org.elasticsearch.indices.recovery.StartRecoveryRequest, org.elasticsearch.action.ActionListener&lt;org.elasticsearch.indices.recovery.RecoveryResponse&gt;)</code> on the primary node that receives the request. The
         <code>StartRecoveryRequest</code> contains information about the local state of the recovery target, based on which the recovery
         source will determine the recovery mechanism (file-based or ops-based) to use.
     </li>
     <li>
        When determining whether to use ops-based recovery the recovery source will check the following conditions
        that must all be true simultaneously for ops-based recovery to be executed:
        <ul>
            <li>
                Target shard and source shard must share the same
                <a href="../../index/engine/Engine.html#HISTORY_UUID_KEY"><code>Engine.HISTORY_UUID_KEY</code></a> in their latest Lucene commit.
            </li>
            <li>
                The source must have retained all operations between the latest sequence number present on the target.
                See <a href="../../index/shard/IndexShard.html#hasCompleteHistoryOperations(java.lang.String,org.elasticsearch.index.engine.Engine.HistorySource,long)"><code>IndexShard.hasCompleteHistoryOperations(java.lang.String, org.elasticsearch.index.engine.Engine.HistorySource, long)</code></a> for details.
            </li>
            <li>
                A peer recovery retention lease must exist for the target shard and it must retain a sequence number below or equal
                to the starting sequence number in <a href="StartRecoveryRequest.html#startingSeqNo()"><code>StartRecoveryRequest.startingSeqNo()</code></a>.
            </li>
        </ul>
     </li>
     <li>
         In case the preconditions for ops-based recovery aren't met, file-based recovery is executed first.
         To trigger file-based recovery, the source node will execute phase 1 of the recovery by invoking
         <code>RecoverySourceHandler.phase1(org.apache.lucene.index.IndexCommit, long, java.util.function.IntSupplier, org.elasticsearch.action.ActionListener&lt;org.elasticsearch.indices.recovery.RecoverySourceHandler.SendFileResult&gt;)</code>. Using the information about the files on the target node
         found in the <code>StartRecoveryRequest</code>, phase 1 will determine what segment files must be copied to the recovery target.
         The information about these files will then be sent to the recovery target via a
         <a href="RecoveryFilesInfoRequest.html" title="class in org.elasticsearch.indices.recovery"><code>RecoveryFilesInfoRequest</code></a>. Once the recovery target has received the list of files
         that will be copied to it, <code>RecoverySourceHandler.sendFiles(org.elasticsearch.index.store.Store, org.elasticsearch.index.store.StoreFileMetadata[], java.util.function.IntSupplier, org.elasticsearch.action.ActionListener&lt;java.lang.Void&gt;)</code> is invoked which
         will send the segment files over to the recovery target via a series of
         <a href="RecoveryFileChunkRequest.html" title="class in org.elasticsearch.indices.recovery"><code>RecoveryFileChunkRequest</code></a>.
         Receiving a <code>RecoveryFilesInfoRequest</code> on the target indicates to it that the recovery will be file-based so it will
         invoke <a href="../../index/shard/IndexShard.html#resetRecoveryStage()"><code>IndexShard.resetRecoveryStage()</code></a> to reset the recovery back to <code>INIT</code> stage and
         then prepare for receiving files and move to stage <code>INDEX</code> again.
     </li>
     <li>
         Once all the file chunks have been received by the recovery target, a retention lease for the latest global checkpoint is
         created by the source node to ensure all remaining operations from the latest global checkpoint are retained for replay in
         the next step of the recovery. Also, after creating the retention lease and before moving on to the next step of the peer
         recovery process, a <a href="RecoveryCleanFilesRequest.html" title="class in org.elasticsearch.indices.recovery"><code>RecoveryCleanFilesRequest</code></a> is sent from the source to the target.
         The target will handle this request by doing the following:
         <ul>
             <li>
                 The file chunks from the previous step were saved to temporary file names. They are now renamed to their original
                 names.
             </li>
             <li>
                 Cleanup all files in the shard directory that are not part of the recovering shard copy.
             </li>
             <li>
                 Trigger creation of a new translog on the target. This moves the recovery stage on the target to
                 <a href="RecoveryState.Stage.html#TRANSLOG"><code>RecoveryState.Stage.TRANSLOG</code></a>.
             </li>
         </ul>
     </li>
     <li>
         After the segment files synchronization from source to the target has finished or was skipped, the translog based recovery
         step is executed by invoking <code>RecoverySourceHandler.prepareTargetForTranslog(int, org.elasticsearch.action.ActionListener&lt;org.elasticsearch.common.unit.TimeValue&gt;)</code> on the
         recovery source. This sends a <code>RecoveryPrepareForTranslogOperationsRequest</code> to the
         recovery target which contains the estimated number of translog operations that have to be copied to the target.
         On the target, this request is handled and triggers a call to
         <a href="../../index/shard/IndexShard.html#openEngineAndSkipTranslogRecovery()"><code>IndexShard.openEngineAndSkipTranslogRecovery()</code></a> which opens a new engine and translog
         and then responds back to the recovery source.
         Once the recovery source receives that response, it invokes
         <code>RecoverySourceHandler.phase2(long, long, org.elasticsearch.index.translog.Translog.Snapshot, long, long, org.elasticsearch.index.seqno.RetentionLeases, long, org.elasticsearch.action.ActionListener&lt;org.elasticsearch.indices.recovery.RecoverySourceHandler.SendSnapshotResult&gt;)</code> to replay outstanding translog operations on the target.
         This is done by sending a series of <a href="RecoveryTranslogOperationsRequest.html" title="class in org.elasticsearch.indices.recovery"><code>RecoveryTranslogOperationsRequest</code></a> to the target
         which will respond with <code>RecoveryTranslogOperationsResponse</code>s which contain the
         maximum persisted local checkpoint for the target. Tracking the maximum of the received local checkpoint values is necessary
         for the next step, finalizing the recovery.
     </li>
     <li>
         After replaying the translog operations on the target, the recovery is finalized by a call to
         <code>RecoverySourceHandler.finalizeRecovery(long, long, org.elasticsearch.action.ActionListener&lt;java.lang.Void&gt;)</code> on the source. With the knowledge that the
         target has received all operations up to the maximum local checkpoint tracked in the previous step, the source
         (which is also the primary) can now update its in-sync checkpoint state by a call to
         <a href="../../index/seqno/ReplicationTracker.html#markAllocationIdAsInSync(java.lang.String,long)"><code>ReplicationTracker.markAllocationIdAsInSync(java.lang.String, long)</code></a>.
         Once the in-sync sequence number information has been persisted successfully, the source sends a
         <code>RecoveryFinalizeRecoveryRequest</code> to the target which contains the global checkpoint
         as well as a sequence number above which the target can trim all operations from its translog since all operations above this
         number have just been replayed in the previous step and were either of the same or a newer version that those in the existing
         translog on the target. This step then also moves the target to the recovery stage
         <a href="RecoveryState.Stage.html#FINALIZE"><code>RecoveryState.Stage.FINALIZE</code></a>.
     </li>
     <li>
         After the finalization step, the recovery source will send a <a href="RecoveryResponse.html" title="class in org.elasticsearch.indices.recovery"><code>RecoveryResponse</code></a> to the
         target which is implemented as a response to the initial <code>StartRecoveryRequest</code> that the target sent to initiate the
         recovery. This leads to a call to <a href="../../index/shard/IndexShard.html#postRecovery(java.lang.String)"><code>IndexShard.postRecovery(java.lang.String)</code></a> which moves the recovery state
         to stage <a href="RecoveryState.Stage.html#DONE"><code>RecoveryState.Stage.DONE</code></a>, triggers a refresh of the shard and moves the
         shard to state <a href="../../index/shard/IndexShardState.html#POST_RECOVERY"><code>IndexShardState.POST_RECOVERY</code></a>. Finally, the recovery target will then
         send a <a href="../../cluster/action/shard/ShardStateAction.StartedShardEntry.html" title="class in org.elasticsearch.cluster.action.shard"><code>ShardStateAction.StartedShardEntry</code></a> transport message to master to inform
         it about the successful start of the shard.
     </li>
     <li>
         After receiving the <code>StartedShardEntry</code>, master will then update the cluster state to reflect the state of the now fully
         recovered recovery target by executing the
         <a href="../../cluster/action/shard/ShardStateAction.ShardStartedClusterStateTaskExecutor.html" title="class in org.elasticsearch.cluster.action.shard"><code>ShardStateAction.ShardStartedClusterStateTaskExecutor</code></a>. The resulting cluster
         state update is then observed by <a href="../../index/shard/IndexShard.html#updateShardState(org.elasticsearch.cluster.routing.ShardRouting,long,java.util.function.BiConsumer,long,java.util.Set,org.elasticsearch.cluster.routing.IndexShardRoutingTable)"><code>IndexShard.updateShardState(org.elasticsearch.cluster.routing.ShardRouting, long, java.util.function.BiConsumer&lt;org.elasticsearch.index.shard.IndexShard, org.elasticsearch.action.ActionListener&lt;org.elasticsearch.index.shard.PrimaryReplicaSyncer.ResyncTask&gt;&gt;, long, java.util.Set&lt;java.lang.String&gt;, org.elasticsearch.cluster.routing.IndexShardRoutingTable)</code></a> which updates the shard state
         on the target node to <a href="../../index/shard/IndexShardState.html#STARTED"><code>IndexShardState.STARTED</code></a> thus completing the peer recovery.
     </li>
 </ol>

 TODO: document other recovery types</div>
</section>
<section class="summary">
<ul class="blockList">
<li class="blockList">
<div class="typeSummary">
<table>
<caption><span>Interface Summary</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Interface</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="MultiChunkTransfer.ChunkRequest.html" title="interface in org.elasticsearch.indices.recovery">MultiChunkTransfer.ChunkRequest</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="PeerRecoveryTargetService.RecoveryListener.html" title="interface in org.elasticsearch.indices.recovery">PeerRecoveryTargetService.RecoveryListener</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RecoveryTargetHandler.html" title="interface in org.elasticsearch.indices.recovery">RecoveryTargetHandler</a></th>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</li>
<li class="blockList">
<div class="typeSummary">
<table>
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="MultiChunkTransfer.html" title="class in org.elasticsearch.indices.recovery">MultiChunkTransfer</a>&lt;Source,&#8203;Request extends <a href="MultiChunkTransfer.ChunkRequest.html" title="interface in org.elasticsearch.indices.recovery">MultiChunkTransfer.ChunkRequest</a>&gt;</th>
<td class="colLast">
<div class="block">File chunks are sent/requested sequentially by at most one thread at any time.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="MultiFileWriter.html" title="class in org.elasticsearch.indices.recovery">MultiFileWriter</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="PeerRecoverySourceService.html" title="class in org.elasticsearch.indices.recovery">PeerRecoverySourceService</a></th>
<td class="colLast">
<div class="block">The source recovery accepts recovery requests from other peer shards and start the recovery process from this
 source shard to the target shard.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="PeerRecoverySourceService.Actions.html" title="class in org.elasticsearch.indices.recovery">PeerRecoverySourceService.Actions</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="PeerRecoveryTargetService.html" title="class in org.elasticsearch.indices.recovery">PeerRecoveryTargetService</a></th>
<td class="colLast">
<div class="block">The recovery target handles recoveries of peer shards of the shard+node to recover to.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="PeerRecoveryTargetService.Actions.html" title="class in org.elasticsearch.indices.recovery">PeerRecoveryTargetService.Actions</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RecoveriesCollection.html" title="class in org.elasticsearch.indices.recovery">RecoveriesCollection</a></th>
<td class="colLast">
<div class="block">This class holds a collection of all on going recoveries on the current node (i.e., the node is the target node
 of those recoveries).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="RecoveriesCollection.RecoveryRef.html" title="class in org.elasticsearch.indices.recovery">RecoveriesCollection.RecoveryRef</a></th>
<td class="colLast">
<div class="block">a reference to <a href="RecoveryTarget.html" title="class in org.elasticsearch.indices.recovery"><code>RecoveryTarget</code></a>, which implements <code>AutoCloseable</code>.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RecoveryCleanFilesRequest.html" title="class in org.elasticsearch.indices.recovery">RecoveryCleanFilesRequest</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="RecoveryFileChunkRequest.html" title="class in org.elasticsearch.indices.recovery">RecoveryFileChunkRequest</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RecoveryFilesInfoRequest.html" title="class in org.elasticsearch.indices.recovery">RecoveryFilesInfoRequest</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="RecoveryRequestTracker.html" title="class in org.elasticsearch.indices.recovery">RecoveryRequestTracker</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RecoveryResponse.html" title="class in org.elasticsearch.indices.recovery">RecoveryResponse</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="RecoverySettings.html" title="class in org.elasticsearch.indices.recovery">RecoverySettings</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RecoverySourceHandler.html" title="class in org.elasticsearch.indices.recovery">RecoverySourceHandler</a></th>
<td class="colLast">
<div class="block">RecoverySourceHandler handles the three phases of shard recovery, which is
 everything relating to copying the segment files as well as sending translog
 operations across the wire once the segments have been copied.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="RecoveryState.html" title="class in org.elasticsearch.indices.recovery">RecoveryState</a></th>
<td class="colLast">
<div class="block">Keeps track of state related to shard recovery.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RecoveryState.FileDetail.html" title="class in org.elasticsearch.indices.recovery">RecoveryState.FileDetail</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="RecoveryState.Index.html" title="class in org.elasticsearch.indices.recovery">RecoveryState.Index</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RecoveryState.RecoveryFilesDetails.html" title="class in org.elasticsearch.indices.recovery">RecoveryState.RecoveryFilesDetails</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="RecoveryState.Timer.html" title="class in org.elasticsearch.indices.recovery">RecoveryState.Timer</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RecoveryState.Translog.html" title="class in org.elasticsearch.indices.recovery">RecoveryState.Translog</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="RecoveryState.VerifyIndex.html" title="class in org.elasticsearch.indices.recovery">RecoveryState.VerifyIndex</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RecoveryTarget.html" title="class in org.elasticsearch.indices.recovery">RecoveryTarget</a></th>
<td class="colLast">
<div class="block">Represents a recovery where the current node is the target node of the recovery.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="RecoveryTranslogOperationsRequest.html" title="class in org.elasticsearch.indices.recovery">RecoveryTranslogOperationsRequest</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RecoveryTransportRequest.html" title="class in org.elasticsearch.indices.recovery">RecoveryTransportRequest</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="ReestablishRecoveryRequest.html" title="class in org.elasticsearch.indices.recovery">ReestablishRecoveryRequest</a></th>
<td class="colLast">
<div class="block">Represents a request for starting a peer recovery.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RemoteRecoveryTargetHandler.html" title="class in org.elasticsearch.indices.recovery">RemoteRecoveryTargetHandler</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="StartRecoveryRequest.html" title="class in org.elasticsearch.indices.recovery">StartRecoveryRequest</a></th>
<td class="colLast">
<div class="block">Represents a request for starting a peer recovery.</div>
</td>
</tr>
</tbody>
</table>
</div>
</li>
<li class="blockList">
<div class="typeSummary">
<table>
<caption><span>Enum Summary</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Enum</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RecoveryState.Stage.html" title="enum in org.elasticsearch.indices.recovery">RecoveryState.Stage</a></th>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</li>
<li class="blockList">
<div class="typeSummary">
<table>
<caption><span>Exception Summary</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Exception</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="DelayRecoveryException.html" title="class in org.elasticsearch.indices.recovery">DelayRecoveryException</a></th>
<td class="colLast">
<div class="block">An exception marking that this recovery attempt should be ignored (since probably, we already recovered).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="PeerRecoveryNotFound.html" title="class in org.elasticsearch.indices.recovery">PeerRecoveryNotFound</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="RecoverFilesRecoveryException.html" title="class in org.elasticsearch.indices.recovery">RecoverFilesRecoveryException</a></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="RecoveryFailedException.html" title="class in org.elasticsearch.indices.recovery">RecoveryFailedException</a></th>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</section>
</div>
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</div>
</div>
</body>
</html>
