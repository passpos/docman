<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>org.elasticsearch.repositories.blobstore (server 7.11.1 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF8">
<meta name="description" content="declaration: package: org.elasticsearch.repositories.blobstore">
<meta name="generator" content="javadoc/PackageWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.js"></script>
</head>
<body class="package-declaration">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flexBox">
<header role="banner" class="flexHeader">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="skipNav"><a id="skip.navbar.top">
<!--   -->
</a></div>
</nav>
</header>
<div class="flexContent">
<main role="main">
<div class="header">
<h1 title="Package" class="title">Package&nbsp;org.elasticsearch.repositories.blobstore</h1>
</div>
<div class="contentContainer">
<section class="packageDescription"><a id="package.description">
<!--   -->
</a>
<div class="block"><p>This package exposes the blobstore repository used by Elasticsearch Snapshots.</p>

 <h2>Preliminaries</h2>

 <p>The <a href="BlobStoreRepository.html" title="class in org.elasticsearch.repositories.blobstore"><code>BlobStoreRepository</code></a> forms the basis of implementations of
 <a href="../Repository.html" title="interface in org.elasticsearch.repositories"><code>Repository</code></a> on top of a blob store. A blobstore can be used as the basis for an implementation
 as long as it provides for GET, PUT, DELETE, and LIST operations. For a read-only repository, it suffices if the blobstore provides only
 GET operations.
 These operations are formally defined as specified by the <a href="../../common/blobstore/BlobContainer.html" title="interface in org.elasticsearch.common.blobstore"><code>BlobContainer</code></a> interface that
 any <code>BlobStoreRepository</code> implementation must provide via its implementation of
 <code>BlobStoreRepository.getBlobContainer()</code>.</p>

 <p>The blob store is written to and read from by master-eligible nodes and data nodes. All metadata related to a snapshot's
 scope and health is written by the master node.</p>
 <p>The data-nodes on the other hand, write the data for each individual shard but do not write any blobs outside of shard directories for
 shards that they hold the primary of. For each shard, the data-node holding the shard's primary writes the actual data in form of
 the shard's segment files to the repository as well as metadata about all the segment files that the repository stores for the shard.</p>

 <p>For the specifics on how the operations on the repository documented below are invoked during the snapshot process please refer to
 the documentation of the <a href="../../snapshots/package-summary.html"><code>org.elasticsearch.snapshots</code></a> package.</p>

 <p><code>BlobStoreRepository</code> maintains the following structure of blobs containing data and metadata in the blob store. The exact
 operations executed on these blobs are explained below.</p>
 <pre>
 <code>
   STORE_ROOT
   |- index-N           - JSON serialized {@link org.elasticsearch.repositories.RepositoryData} containing a list of all snapshot ids
   |                      and the indices belonging to each snapshot, N is the generation of the file
   |- index.latest      - contains the numeric value of the latest generation of the index file (i.e. N from above)
   |- incompatible-snapshots - list of all snapshot ids that are no longer compatible with the current version of the cluster
   |- snap-20131010.dat - SMILE serialized {@link org.elasticsearch.snapshots.SnapshotInfo} for snapshot "20131010"
   |- meta-20131010.dat - SMILE serialized {@link org.elasticsearch.cluster.metadata.Metadata} for snapshot "20131010"
   |                      (includes only global metadata)
   |- snap-20131011.dat - SMILE serialized {@link org.elasticsearch.snapshots.SnapshotInfo} for snapshot "20131011"
   |- meta-20131011.dat - SMILE serialized {@link org.elasticsearch.cluster.metadata.Metadata} for snapshot "20131011"
   .....
   |- indices/ - data for all indices
      |- Ac1342-B_x/ - data for index "foo" which was assigned the unique id Ac1342-B_x (not to be confused with the actual index uuid)
      |  |             in the repository
      |  |- meta-20131010.dat - JSON Serialized {@link org.elasticsearch.cluster.metadata.IndexMetadata} for index "foo"
      |  |- 0/ - data for shard "0" of index "foo"
      |  |  |- __1                      \  (files with numeric names were created by older ES versions)
      |  |  |- __2                      |
      |  |  |- __VPO5oDMVT5y4Akv8T_AO_A |- files from different segments see snap-* for their mappings to real segment files
      |  |  |- __1gbJy18wS_2kv1qI7FgKuQ |
      |  |  |- __R8JvZAHlSMyMXyZc2SS8Zg /
      |  |  .....
      |  |  |- snap-20131010.dat - SMILE serialized {@link org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot} for
      |  |  |                      snapshot "20131010"
      |  |  |- snap-20131011.dat - SMILE serialized {@link org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot} for
      |  |  |                      snapshot "20131011"
      |  |  |- index-123         - SMILE serialized {@link org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshots} for
      |  |  |                      the shard (files with numeric suffixes were created by older versions, newer ES versions use a uuid
      |  |  |                      suffix instead)
      |  |
      |  |- 1/ - data for shard "1" of index "foo"
      |  |  |- __1
      |  |  |- index-Zc2SS8ZgR8JvZAHlSMyMXy - SMILE serialized {@code BlobStoreIndexShardSnapshots} for the shard
      |  |  .....
      |  |
      |  |-2/
      |  ......
      |
      |- 1xB0D8_B3y/ - data for index "bar" which was assigned the unique id of 1xB0D8_B3y in the repository
      ......
 </code>
 </pre>

 <h2>Getting the Repository's RepositoryData</h2>

 <p>Loading the <a href="../RepositoryData.html" title="class in org.elasticsearch.repositories"><code>RepositoryData</code></a> that holds the list of all snapshots as well as the mapping of
 indices' names to their repository <a href="../IndexId.html" title="class in org.elasticsearch.repositories"><code>IndexId</code></a> is done by invoking
 <a href="BlobStoreRepository.html#getRepositoryData(org.elasticsearch.action.ActionListener)"><code>BlobStoreRepository.getRepositoryData(org.elasticsearch.action.ActionListener&lt;org.elasticsearch.repositories.RepositoryData&gt;)</code></a> and implemented as follows:</p>
 <ol>
 <li>
 <ol>
 <li>The blobstore repository stores the <code>RepositoryData</code> in blobs named with incrementing suffix <code>N</code> at <code>/index-N</code>
 directly under the repository's root.</li>
 <li>For each <a href="BlobStoreRepository.html" title="class in org.elasticsearch.repositories.blobstore"><code>BlobStoreRepository</code></a> an entry of type
 <a href="../../cluster/metadata/RepositoryMetadata.html" title="class in org.elasticsearch.cluster.metadata"><code>RepositoryMetadata</code></a> exists in the cluster state. It tracks the current valid
 generation <code>N</code> as well as the latest generation that a write was attempted for.</li>
 <li>The blobstore also stores the most recent <code>N</code> as a 64bit long in the blob <code>/index.latest</code> directly under the
 repository's root.</li>
 </ol>
 </li>
 <li>
 <ol>
 <li>First, find the most recent <code>RepositoryData</code> by getting a list of all index-N blobs through listing all blobs with prefix
 "index-" under the repository root and then selecting the one with the highest value for N.</li>
 <li>If this operation fails because the repository's <code>BlobContainer</code> does not support list operations (in the case of read-only
 repositories), read the highest value of N from the index.latest blob.</li>
 </ol>
 </li>
 <li>
 <ol>
 <li>Use the just determined value of <code>N</code> and get the <code>/index-N</code> blob and deserialize the <code>RepositoryData</code> from it.</li>
 <li>If no value of <code>N</code> could be found since neither an <code>index.latest</code> nor any <code>index-N</code> blobs exist in the repository,
 it is assumed to be empty and <a href="../RepositoryData.html#EMPTY"><code>RepositoryData.EMPTY</code></a> is returned.</li>
 </ol>
 </li>
 </ol>

 <h2>Writing Updated RepositoryData to the Repository</h2>

 <p>Writing an updated <a href="../RepositoryData.html" title="class in org.elasticsearch.repositories"><code>RepositoryData</code></a> to a blob store repository is an operation that uses
 the cluster state to ensure that a specific <code>index-N</code> blob is never accidentally overwritten in a master failover scenario.
 The specific steps to writing a new <code>index-N</code> blob and thus making changes from a snapshot-create or delete operation visible
 to read operations on the repository are as follows and all run on the master node:</p>

 <ol>
 <li>Write an updated value of <a href="../../cluster/metadata/RepositoryMetadata.html" title="class in org.elasticsearch.cluster.metadata"><code>RepositoryMetadata</code></a> for the repository that has the same
 <a href="../../cluster/metadata/RepositoryMetadata.html#generation()"><code>RepositoryMetadata.generation()</code></a> as the existing entry and has a value of
 <a href="../../cluster/metadata/RepositoryMetadata.html#pendingGeneration()"><code>RepositoryMetadata.pendingGeneration()</code></a> one greater than the <code>pendingGeneration</code> of the
 existing entry.</li>
 <li>On the same master node, after the cluster state has been updated in the first step, write the new <code>index-N</code> blob and
 also update the contents of the <code>index.latest</code> blob. Note that updating the index.latest blob is done on a best effort
 basis and that there is a chance for a stuck master-node to overwrite the contents of the <code>index.latest</code> blob after a newer
 <code>index-N</code> has been written by another master node. This is acceptable since the contents of <code>index.latest</code> are not used
 during normal operation of the repository and must only be correct for purposes of mounting the contents of a
 <a href="BlobStoreRepository.html" title="class in org.elasticsearch.repositories.blobstore"><code>BlobStoreRepository</code></a> as a read-only url repository.</li>
 <li>After the write has finished, set the value of <code>RepositoriesState.State#generation</code> to the value used for
 <code>RepositoriesState.State#pendingGeneration</code> so that the new entry for the state of the repository has <code>generation</code> and
 <code>pendingGeneration</code> set to the same value to signalize a clean repository state with no potentially failed writes newer than the
 last valid <code>index-N</code> blob in the repository.</li>
 </ol>

 <p>If either of the last two steps in the above fails or master fails over to a new node at any point, then a subsequent operation
 trying to write a new <code>index-N</code> blob will never use the same value of <code>N</code> used by a previous attempt. It will always start
 over at the first of the above three steps, incrementing the <code>pendingGeneration</code> generation before attempting a write, thus
 ensuring no overwriting of a <code>index-N</code> blob ever to occur. The use of the cluster state to track the latest repository generation
 <code>N</code> and ensuring no overwriting of <code>index-N</code> blobs to ever occur allows the blob store repository to properly function even
 on blob stores with neither a consistent list operation nor an atomic "write but not overwrite" operation.</p>

 <h2>Creating a Snapshot</h2>

 <p>Creating a snapshot in the repository happens in the three steps described in detail below.</p>

 <h3>Initializing a Snapshot in the Repository (Mixed Version Clusters only)</h3>

 <p>In mixed version clusters that contain a node older than
 <a href="../../snapshots/SnapshotsService.html#NO_REPO_INITIALIZE_VERSION"><code>SnapshotsService.NO_REPO_INITIALIZE_VERSION</code></a>, creating a snapshot in the repository starts with a
 call to <a href="../Repository.html#initializeSnapshot(org.elasticsearch.snapshots.SnapshotId,java.util.List,org.elasticsearch.cluster.metadata.Metadata)"><code>Repository.initializeSnapshot(org.elasticsearch.snapshots.SnapshotId, java.util.List&lt;org.elasticsearch.repositories.IndexId&gt;, org.elasticsearch.cluster.metadata.Metadata)</code></a> which the blob store repository implements via the
 following actions:</p>
 <ol>
 <li>Verify that no snapshot by the requested name exists.</li>
 <li>Write a blob containing the cluster metadata to the root of the blob store repository at <code>/meta-${snapshot-uuid}.dat</code></li>
 <li>Write the metadata for each index to a blob in that index's directory at
 <code>/indices/${index-snapshot-uuid}/meta-${snapshot-uuid}.dat</code></li>
 </ol>
 TODO: Remove this section once BwC logic it references is removed

 <h3>Writing Shard Data (Segments)</h3>

 <p>Once all the metadata has been written by the snapshot initialization, the snapshot process moves on to writing the actual shard data
 to the repository by invoking <a href="../Repository.html#snapshotShard(org.elasticsearch.index.store.Store,org.elasticsearch.index.mapper.MapperService,org.elasticsearch.snapshots.SnapshotId,org.elasticsearch.repositories.IndexId,org.apache.lucene.index.IndexCommit,java.lang.String,org.elasticsearch.index.snapshots.IndexShardSnapshotStatus,org.elasticsearch.Version,java.util.Map,org.elasticsearch.action.ActionListener)"><code>Repository.snapshotShard(org.elasticsearch.index.store.Store, org.elasticsearch.index.mapper.MapperService, org.elasticsearch.snapshots.SnapshotId, org.elasticsearch.repositories.IndexId, org.apache.lucene.index.IndexCommit, java.lang.String, org.elasticsearch.index.snapshots.IndexShardSnapshotStatus, org.elasticsearch.Version, java.util.Map&lt;java.lang.String, java.lang.Object&gt;, org.elasticsearch.action.ActionListener&lt;java.lang.String&gt;)</code></a> on the data-nodes that hold the primaries
 for the shards in the current snapshot. It is implemented as follows:</p>

 <p>Note:</p>
 <ul>
 <li>For each shard <code>i</code> in a given index, its path in the blob store is located at <code>/indices/${index-snapshot-uuid}/${i}</code></li>
 <li>All the following steps are executed exclusively on the shard's primary's data node.</li>
 </ul>

 <ol>
 <li>Create the <code>IndexCommit</code> for the shard to snapshot.</li>
 <li>Get the <a href="../../index/snapshots/blobstore/BlobStoreIndexShardSnapshots.html" title="class in org.elasticsearch.index.snapshots.blobstore"><code>BlobStoreIndexShardSnapshots</code></a> blob
 with name <code>index-${uuid}</code> with the <code>uuid</code> generation returned by
 <a href="../ShardGenerations.html#getShardGen(org.elasticsearch.repositories.IndexId,int)"><code>ShardGenerations.getShardGen(org.elasticsearch.repositories.IndexId, int)</code></a> to get the information of what segment files are
 already available in the blobstore.</li>
 <li>By comparing the files in the <code>IndexCommit</code> and the available file list from the previous step, determine the segment files
 that need to be written to the blob store. For each segment that needs to be added to the blob store, generate a unique name by combining
 the segment data blob prefix <code>__</code> and a UUID and write the segment to the blobstore.</li>
 <li>After completing all segment writes, a blob containing a
 <a href="../../index/snapshots/blobstore/BlobStoreIndexShardSnapshot.html" title="class in org.elasticsearch.index.snapshots.blobstore"><code>BlobStoreIndexShardSnapshot</code></a> with name <code>snap-${snapshot-uuid}.dat</code> is written to
 the shard's path and contains a list of all the files referenced by the snapshot as well as some metadata about the snapshot. See the
 documentation of <code>BlobStoreIndexShardSnapshot</code> for details on its contents.</li>
 <li>Once all the segments and the <code>BlobStoreIndexShardSnapshot</code> blob have been written, an updated
 <code>BlobStoreIndexShardSnapshots</code> blob is written to the shard's path with name <code>index-${newUUID}</code>.</li>
 </ol>

 <h3>Finalizing the Snapshot</h3>

 <p>After all primaries have finished writing the necessary segment files to the blob store in the previous step, the master node moves on
 to finalizing the snapshot by invoking <a href="../Repository.html#finalizeSnapshot(org.elasticsearch.repositories.ShardGenerations,long,org.elasticsearch.cluster.metadata.Metadata,org.elasticsearch.snapshots.SnapshotInfo,org.elasticsearch.Version,java.util.function.Function,org.elasticsearch.action.ActionListener)"><code>Repository.finalizeSnapshot(org.elasticsearch.repositories.ShardGenerations, long, org.elasticsearch.cluster.metadata.Metadata, org.elasticsearch.snapshots.SnapshotInfo, org.elasticsearch.Version, java.util.function.Function&lt;org.elasticsearch.cluster.ClusterState, org.elasticsearch.cluster.ClusterState&gt;, org.elasticsearch.action.ActionListener&lt;org.elasticsearch.repositories.RepositoryData&gt;)</code></a>. This method executes the
 following actions in order:</p>
 <ol>
 <li>Write a blob containing the cluster metadata to the root of the blob store repository at <code>/meta-${snapshot-uuid}.dat</code></li>
 <li>Write the metadata for each index to a blob in that index's directory at
 <code>/indices/${index-snapshot-uuid}/meta-${snapshot-uuid}.dat</code></li>
 <li>Write the <a href="../../snapshots/SnapshotInfo.html" title="class in org.elasticsearch.snapshots"><code>SnapshotInfo</code></a> blob for the given snapshot to the key <code>/snap-${snapshot-uuid}.dat</code>
 directly under the repository root.</li>
 <li>Write an updated <code>RepositoryData</code> blob containing the new snapshot.</li>
 </ol>

 <h2>Deleting a Snapshot</h2>

 <p>Deleting a snapshot is an operation that is exclusively executed on the master node that runs through the following sequence of
 action when <a href="BlobStoreRepository.html#deleteSnapshots(java.util.Collection,long,org.elasticsearch.Version,org.elasticsearch.action.ActionListener)"><code>BlobStoreRepository.deleteSnapshots(java.util.Collection&lt;org.elasticsearch.snapshots.SnapshotId&gt;, long, org.elasticsearch.Version, org.elasticsearch.action.ActionListener&lt;org.elasticsearch.repositories.RepositoryData&gt;)</code></a> is invoked:</p>

 <ol>
 <li>Get the current <code>RepositoryData</code> from the latest <code>index-N</code> blob at the repository root.</li>
 <li>For each index referenced by the snapshot:
 <ol>
 <li>Delete the snapshot's <code>IndexMetadata</code> at <code>/indices/${index-snapshot-uuid}/meta-${snapshot-uuid}</code>.</li>
 <li>Go through all shard directories <code>/indices/${index-snapshot-uuid}/${i}</code> and:
 <ol>
 <li>Remove the <code>BlobStoreIndexShardSnapshot</code> blob at <code>/indices/${index-snapshot-uuid}/${i}/snap-${snapshot-uuid}.dat</code>.</li>
 <li>List all blobs in the shard path <code>/indices/${index-snapshot-uuid}</code> and build a new <code>BlobStoreIndexShardSnapshots</code> from
 the remaining <code>BlobStoreIndexShardSnapshot</code> blobs in the shard. Afterwards, write it to the next shard generation blob at
 <code>/indices/${index-snapshot-uuid}/${i}/index-${uuid}</code> (The shard's generation is determined from the map of shard generations in
 the <a href="../RepositoryData.html" title="class in org.elasticsearch.repositories"><code>RepositoryData</code></a> in the root <code>index-${N}</code> blob of the repository.</li>
 <li>Collect all segment blobs (identified by having the data blob prefix <code>__</code>) in the shard directory which are not referenced by
 the new <code>BlobStoreIndexShardSnapshots</code> that has been written in the previous step as well as the previous index-${uuid}
 blob so that it can be deleted at the end of the snapshot delete process.</li>
 </ol>
 </li>
 <li>Write an updated <code>RepositoryData</code> blob with the deleted snapshot removed and containing the updated repository generations
 that changed for the shards affected by the delete.</li>
 <li>Delete the global <code>Metadata</code> blob <code>meta-${snapshot-uuid}.dat</code> stored directly under the repository root for the snapshot
 as well as the <code>SnapshotInfo</code> blob at <code>/snap-${snapshot-uuid}.dat</code>.</li>
 <li>Delete all unreferenced blobs previously collected when updating the shard directories. Also, remove any index folders or blobs
 under the repository root that are not referenced by the new <code>RepositoryData</code> written in the previous step.</li>
 </ol>
 </li>
 </ol></div>
</section>
<section class="summary">
<ul class="blockList">
<li class="blockList">
<div class="typeSummary">
<table>
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="BlobStoreRepository.html" title="class in org.elasticsearch.repositories.blobstore">BlobStoreRepository</a></th>
<td class="colLast">
<div class="block">BlobStore - based implementation of Snapshot Repository</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="ChecksumBlobStoreFormat.html" title="class in org.elasticsearch.repositories.blobstore">ChecksumBlobStoreFormat</a>&lt;T extends org.elasticsearch.common.xcontent.ToXContent&gt;</th>
<td class="colLast">
<div class="block">Snapshot metadata file format used in v2.0 and above</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="FileRestoreContext.html" title="class in org.elasticsearch.repositories.blobstore">FileRestoreContext</a></th>
<td class="colLast">
<div class="block">This context will execute a file restore of the lucene files.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="MeteredBlobStoreRepository.html" title="class in org.elasticsearch.repositories.blobstore">MeteredBlobStoreRepository</a></th>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</section>
</div>
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</div>
</div>
</body>
</html>
