<!DOCTYPE html>
<html class="no-js" lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width,initial-scale=1">

        <title>设置和使用自定义安装类型 | Composer 中文文档 | Composer 中文网</title>
        <meta name="description" content="Composer 是 PHP 中用来管理依赖（dependency）关系的工具">
        <meta name="keywords" content="PHP, Composer, Packagist, 依赖管理, npm, Symfony, Laravel">

        <link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
        <link rel="stylesheet" href="../assets/css/style.css">
        <link rel="stylesheet" href="../assets/css/libs/prism.css">

        <script src="https://cdn.bootcss.com/modernizr/2.8.2/modernizr.min.js"></script>
    </head>

    <body>
        <div id="container">
            <header>
                    <a href="../docs_phpcomposer_default.html">首页</a>
                    <a href="../00-intro.html">入门</a>
                    <a href="https://getcomposer.org/download/" target="_blank">下载</a>
                    <a href="https://packagist.org/" target="_blank">安装包列表</a>
                    <a class="last" href="https://pkg.phpcomposer.com/" target="_blank">中国镜像</a>
            </header>
            <div id="main" role="main">
    
    <!--
    tagline: Modify the way certain types of packages are installed
-->
<h1>设置和使用自定义安装类型</h1>
<h2>概要</h2>
<p>有时需要在包的安装过程中执行其它的动作，例如：将它安装在默认的 <code>vendor</code> 以外的其它目录。</p>
<p>在这些情况下，你可以考虑创建一个自定义安装程序来处理特定的逻辑。</p>
<h2>调用自定义安装程序</h2>
<p>假设你的项目已经有了一个自定义的安装模块，那么如何根据 <a href="../04-schema.html#type">安装类型</a> 正确调用你包文件中的安装程序就成为了一个问题。</p>
<blockquote>
<p><em>参见见下一章，如何通过指令创建自定义安装程序。</em></p>
</blockquote>
<p>任何自定义安装程序都要通过 <a href="../04-schema.html#type">type</a> 属性来识别。一旦被确认，它将完全覆盖默认的安装程序，并执行自己的安装逻辑。</p>
<p>一个实际用例：</p>
<blockquote>
<p>phpDocumentor 的特殊模板需要安装在 /vendor 以外的其它目录中。
因此他们选择 <code>phpdocumentor-template</code> <a href="../04-schema.html#type">安装类型</a> 并为此类型创建了一个插件，以便将他们的模板发送到正确的目录中。</p>
</blockquote>
<p>在这样一个模板包的例子中 composer.json 将使用以下设置：</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;phpdocumentor/template-responsive&quot;,
    &quot;type&quot;: &quot;phpdocumentor-template&quot;,
    &quot;require&quot;: {
        &quot;phpdocumentor/template-installer-plugin&quot;: &quot;*&quot;
    }
}
</code></pre>
<blockquote>
<p><strong>重要提示：</strong> 为了确保这个模板安装程序在安装模板包之前就已存在，模板包必须写入对此安装程序包的依赖。</p>
</blockquote>
<h2>创建一个安装程序</h2>
<p>一个自定义安装程序通常是以 Composer 插件的形式存在，并包含有一个类，它实现了 <a href="https://github.com/composer/composer/blob/master/src/Composer/Plugin/PluginInterface.php" target="_blank"><code>Composer\Installer\InstallerInterface</code></a> 这个接口。</p>
<p>一个基本的安装程序插件必须由3个文件组成：</p>
<ol>
<li>包文件：composer.json</li>
<li>插件类，例如：<code>My\Project\Composer\Plugin.php</code>，其中的类必须实现 <code>Composer\Plugin\PluginInterface</code> 接口。</li>
<li>安装程序类，例如：<code>My\Project\Composer\Installer.php</code>，其中的类必须实现 <code>Composer\Installer\InstallerInterface</code> 接口。</li>
</ol>
<h3>composer.json</h3>
<p>此处的包文件和普通资源包是相同的，但需要满足以下条件：</p>
<ol>
<li><a href="../04-schema.html#type">type</a> 属性必须是 <code>composer-plugin</code>。</li>
<li><a href="../04-schema.html#extra">extra</a> 属性必须包含 <code>class</code> 元素，它定义了插件类的名称（包含命名空间）。如果这个包有多个插件类，可以使用数组的形式进行定义。</li>
</ol>
<p>实例：</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;phpdocumentor/template-installer-plugin&quot;,
    &quot;type&quot;: &quot;composer-plugin&quot;,
    &quot;license&quot;: &quot;MIT&quot;,
    &quot;autoload&quot;: {
        &quot;psr-0&quot;: {&quot;phpDocumentor\\Composer&quot;: &quot;src/&quot;}
    },
    &quot;extra&quot;: {
        &quot;class&quot;: &quot;phpDocumentor\\Composer\\TemplateInstallerPlugin&quot;
    },
    &quot;require&quot;: {
        &quot;composer-plugin-api&quot;: &quot;1.0.0&quot;
    }
}
</code></pre>
<h3>插件类</h3>
<p>这个类定义了 Composer 的插件，它必须实现 <a href="https://github.com/composer/composer/blob/master/src/Composer/Plugin/PluginInterface.php" target="_blank"><code>Composer\Plugin\PluginInterface</code></a> 这个接口。它可以在 <code>activate()</code> 方法中注册自定义安装程序。</p>
<p>这个类可以被放在任何位置、使用任何名字，只要能够根据 <code>extra.class</code> 中的定义被自动加载即可。</p>
<p>实例：</p>
<pre><code class="language-php">&lt;?php

namespace phpDocumentor\Composer;

use Composer\Composer;
use Composer\IO\IOInterface;
use Composer\Plugin\PluginInterface;

class TemplateInstallerPlugin implements PluginInterface
{
    public function activate(Composer $composer, IOInterface $io)
    {
        $installer = new TemplateInstaller($io, $composer);
        $composer-&gt;getInstallationManager()-&gt;addInstaller($installer);
    }
}
</code></pre>
<h3>自定义安装程序类</h3>
<p>这个类用于执行自定义的安装过程，它必须实现 <a href="https://github.com/composer/composer/blob/master/src/Composer/Installer/InstallerInterface.php" target="_blank"><code>Composer\Installer\InstallerInterface</code></a> 这个接口（或者继承了另一个实现此接口的安装程序类）。它将会对 <a href="../04-schema.html#type">安装类型</a> 中定义的字符串执行 <code>supports()</code> 方法验证，一旦通过就采用对应的安装程序。</p>
<blockquote>
<p><strong>注意：</strong> <em>请慎重选择你的 <a href="../04-schema.html#type">安装类型</a> 名称，建议遵循这样的格式：<code>vendor-type</code></em>。例如：<code>phpdocumentor-template</code>。</p>
</blockquote>
<p>InstallerInterface 类定义了以下方法（请查阅源码以获得更详细的信息）：</p>
<ul>
<li><strong>supports()</strong> 在这里测试你发布的这个安装程序名称是否通过 <a href="../04-schema.html#type">安装类型</a> 匹配（参见示例）。只有正确匹配的资源包才会使用此安装程序进行安装。</li>
<li><strong>isInstalled()</strong> 确定支持的资源包是否已安装。</li>
<li><strong>install()</strong> 这里你可以定义在安装时需要执行的动作。</li>
<li><strong>update()</strong> 这里你可以定义在更新时需要执行的动作。当 Composer 调用更新参数时这是必须的。</li>
<li><strong>uninstall()</strong> 这里你可以定义在移除一个包时需要执行的动作。</li>
<li><strong>getInstallPath()</strong> 这个方法需要返回一个资源包将要安装的位置。<em>相对于 composer.json 文件的位置。</em></li>
</ul>
<p>实例：</p>
<pre><code class="language-php">&lt;?php

namespace phpDocumentor\Composer;

use Composer\Package\PackageInterface;
use Composer\Installer\LibraryInstaller;

class TemplateInstaller extends LibraryInstaller
{
    /**
     * {@inheritDoc}
     */
    public function getPackageBasePath(PackageInterface $package)
    {
        $prefix = substr($package-&gt;getPrettyName(), 0, 23);
        if ('phpdocumentor/template-' !== $prefix) {
            throw new \InvalidArgumentException(
                'Unable to install template, phpdocumentor templates '
                .'should always start their package name with '
                .'&quot;phpdocumentor/template-&quot;'
            );
        }

        return 'data/templates/'.substr($package-&gt;getPrettyName(), 23);
    }

    /**
     * {@inheritDoc}
     */
    public function supports($packageType)
    {
        return 'phpdocumentor-template' === $packageType;
    }
}
</code></pre>
<p>这个例子演示了，简单的继承 <a href="https://github.com/composer/composer/blob/master/src/Composer/Installer/LibraryInstaller.php" target="_blank"><code>Composer\Installer\LibraryInstaller</code></a> 类来剥离 <code>phpdocumentor/template-</code> 前缀，并用剩余的部分重新组装了一个完全不同的安装路径。</p>
<blockquote>
<p><em>并非安装在 <code>/vendor</code> 目录，任何使用这个安装程序的资源包，将被放置在 <code>/data/templates/&lt;stripped name&gt;</code> 目录中。</em></p>
</blockquote>


    <p class="fork-and-edit">
        如果您发现文档中有错误，或者能够帮我们完善文档，请提交到我们的 <a href="https://github.com/5-say/composer-doc-cn" target="_blank">Github 仓库吧</a>！
    </p>
            </div>
            <footer>

                <p class="license">Composer 以及本网站上的所有内容全部遵循 <a href="https://github.com/composer/composer/blob/master/LICENSE" target="_blank">MIT 开源协议</a>。</p>
            </footer>
        </div>

        <script src="http://docs.phpcomposer.com/assets/js/libs/prism.js"></script>
        <script type="text/javascript">
        var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
        document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F16e97907ef84179ff8cd833509017a96' type='text/javascript'%3E%3C/script%3E"));
        </script>
    </body>
</html>
